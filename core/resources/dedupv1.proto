/*
 * dedupv1 - iSCSI based Deduplication System for Linux
 *
 * (C) 2008 Dirk Meister
 * (C) 2009 - 2011, Dirk Meister, Paderborn Center for Parallel Computing
 */

 // compile with /opt/dedupv1/bin/protoc --cpp_out=. dedupv1.proto with working directory common/resources
 
message BlockMappingData {
    optional uint64 block_id = 1;
    repeated BlockMappingItemData items = 2;
    optional uint32 version_counter = 3;
    // 4 is obsolete
    // 5 is obsolete
    optional uint64 event_log_id = 6;
    optional bytes checksum = 7;
}

message BlockMappingItemData {
    required bytes fp = 1;
    optional uint64 data_address = 2;

    // only set when not 0
    optional uint32 chunk_offset = 3;
    optional uint32 size = 4;
 }

message ChunkMappingData {
    optional uint64 data_address = 1;
    optional uint64 last_block_hint = 2;
 }

message ContainerData {
    optional uint64 primary_id = 1;
    optional uint32 container_size = 2;
    repeated ContainerItemData items = 3;
    // 4 is obsolete
    optional uint32 commit_time = 5;

    // an adler-32 checksum
    optional uint32 checksum = 7;
}

message ContainerItemData {
    optional bytes fp = 1;
    optional uint32 position_offset = 2;
    optional uint32 item_size = 3;
    optional uint32 raw_size = 4;
    optional bool deleted = 5;
    optional bool indexed = 7;
    optional uint64 original_id = 6;
}

/**
 * A partial contains either partial items or an address info
 * If there is a partial items needing an import, there is also
 * an address info in some partial file.
 */ 
message ContainerPartialData {
    repeated ContainerPartialItemData partial_item = 1;
    optional ContainerPartialAddressData address_info = 2;
}

message ContainerPartialAddressData {
    optional uint64 container_id = 1;
    optional ContainerStorageAddressData address = 2;
}

message ContainerPartialItemData {
    optional bytes fp = 1;
    optional uint64 container_id = 2;
    optional bool indexed = 3;
    optional bytes data = 4;
}

enum CompressionMode {
    COMPRESSION_NO = 0;
    COMPRESSION_DEFLATE = 1;
    COMPRESSION_GZIP = 2;
    COMPRESSION_BZ2 = 3;
    COMPRESSION_SNAPPY = 4;
    COMPRESSION_LZ4 = 5;
}

message ContainerItemValueData {
    optional uint32 on_disk_size = 3;
    optional CompressionMode compression = 4 [default = COMPRESSION_NO];
}

message Limit {
    required fixed32 size = 1;
}

message ContainerFileData {
    // the filename is more a hint or so, as the renaming should be possible
    optional string filename = 1;
    // if not preallocated, the maximal file size
    // in all cases, the file size for which container are allocated in it.
    optional uint64 file_size = 2;

    optional string uuid = 3;
}

message ContainerPartialFileData {
    optional string filename = 1;

    optional string uuid = 2;
}

message ContainerSuperblockData {
    optional string uuid = 1;
}

message ContainerLogfileData {
    optional uint64 last_given_container_id = 1;
    optional uint32 container_size = 2;

    optional uint32 size = 3;
    repeated ContainerFileData file = 4;
    repeated ContainerPartialFileData partial_file = 5;
}

message SystemStartEventData {
    optional bool create = 1;
    optional bool dirty = 2;
    optional bool forced = 3;
    optional bool crashed = 4;
}

/**
 * Union message for all event data types
 * A event should contain one and only one sub message. The matching
 * from the event type to the message to fill is obvious by the name.
 */
message LogEventData {
    optional int32 event_type = 97;

    optional ContainerOpenedEventData container_opened_event = 1;
    optional ContainerCommittedEventData container_committed_event = 2;
    optional ContainerMergedEventData container_merged_event = 3;
    optional ContainerDeletedEventData container_deleted_event = 4;
    optional ContainerMoveEventData container_moved_event = 5;
    optional ContainerCommitFailedEventData container_commit_failed_event = 6;

    optional VolumeAttachedEventData volume_attached_event = 7;
    optional VolumeDetachedEventData volume_detached_event = 8;

    optional BlockMappingWrittenEventData block_mapping_written_event = 9;

    optional BlockMappingDeletedEventData block_mapping_deleted_event = 11;

    optional SystemStartEventData system_start_event = 15;

    /**
     * Mainly used for testing
     */
    optional MessageData message_data = 98;
}

message LogEntryData {
    // 1 is deleted
    optional int64 log_id = 7;
    // 2 is deleted
    optional bytes value = 3;
    // 4 is deleted
    optional uint32 partial_index = 5;
    optional uint32 partial_count = 6;
    optional int64 last_fully_written_log_id = 8;
}

message ContainerOpenedEventData {
    required uint64 container_id = 1;
    optional ContainerStorageAddressData address = 2;
}

message ContainerCommittedEventData {
    required uint64 container_id = 1;
    // 2 - 3 are obsolete
    optional ContainerStorageAddressData address = 4;

    optional uint32 item_count = 5;
    optional uint32 active_data_size = 6;
}

message ContainerMergedEventData {
    required uint64 first_id = 1;
    required uint64 second_id = 2;
    repeated uint64 first_secondary_id = 3 [packed=true];
    repeated uint64 second_secondary_id = 4 [packed=true];

    // 5 - 10 are obsolete

    optional ContainerStorageAddressData first_address = 13;
    optional ContainerStorageAddressData second_address = 14;

    optional ContainerStorageAddressData new_address = 15;

    optional uint64 new_primary_id = 18;
    repeated uint64 new_secondary_id = 11 [packed=true];

    repeated uint64 unused_ids = 12 [packed=true];

    optional uint32 new_item_count = 16;
    optional uint32 new_active_data_size = 17;
}

message ContainerDeletedEventData {
    required uint64 container_id = 1;
    repeated uint64 secondary_container_id = 2 [packed=true];

    // 3 - 4 are obsolete

    optional ContainerStorageAddressData address = 5;
    optional uint64 file_offset = 4;
}

message ContainerMoveEventData {
    required uint64 container_id = 1;

    // 2 - 5 are obsolete
    optional ContainerStorageAddressData old_address = 6;
    optional ContainerStorageAddressData new_address = 7;

    optional uint64 active_data_size = 8;
    optional uint64 old_active_data_size = 9;

    optional uint32 item_count = 10;
    optional uint32 old_item_count = 11;
}

message ContainerCommitFailedEventData {
  required uint64 container_id = 1;
  repeated bytes item_key = 2;
}

message VolumeAttachedEventData {
    required uint32 volume_id = 1;
}

message VolumeDetachedEventData {
    required uint32 volume_id = 1;
}

message BlockMappingWrittenEventData {
    optional BlockMappingData mapping = 1;
}

message BlockMappingDeletedEventData {
    optional BlockMappingData original_block_mapping = 1;
}

message BlockIndexLogfileData {
}

message ChunkIndexLogfileData {
}

message BloomFilterLogfileData {
    optional uint64 filter_size = 1;
    optional uint32 k = 2;
    optional ContainerTrackerData container_tracker = 3;
}

message ContainerGreedyGCCandidateItemData {
    optional uint64 address = 1;
    optional uint32 active_data_size = 2;
    optional uint32 active_item_count = 3;
}

message ContainerGreedyGCCandidateData {
    repeated ContainerGreedyGCCandidateItemData item = 1;
}

message ContainerStorageAddressData {
    optional uint64 primary_id = 3;
    optional uint32 file_index = 1;
    optional uint64 file_offset = 2;

    // log id of the last change
    optional uint64 log_id = 4;
}

message BitmapAllocatorItemData {
    optional uint32 free_count = 1;
    optional bytes bitmap = 2;
}

message ContainerTrackerData {
    // sorted
    repeated uint64 container_id = 1 [packed=true];
    optional uint64 highest_seen_container_id = 2;
}

message LogReplayIDData {
    optional int64 replay_id = 1;
}

message LogLogIDData {
    optional int64 log_id = 1;
}

message LogStateData {
    optional int64 limit_id = 1;
    optional int64 log_entry_width = 2;
}

// used only for testing
message MessageData {
  optional string message = 1;
}

message BlockWriteFailedData {
}

